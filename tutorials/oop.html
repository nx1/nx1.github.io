<html>
<head>
    <title>nx1.info | OOP Notes</title>
    <link rel="icon" type="image/x-icon" href="../favicon.png">
	<link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<div style="font-family: monospace; white-space: pre;">
<h1>nx1.info | Practical Object-Oriented Design in Python</h1>

These are notes from the book Practical Object-Oriented Design in Ruby that I
have adapted into Python.

<a href="https://www.r-5.org/files/books/computers/dev-teams/diagrams/Sandi_Metz-Practical_Object-Oriented_Design_in_Ruby-EN.pdf">https://www.r-5.org/files/books/computers/dev-teams/diagrams/Sandi_Metz-Practical_Object-Oriented_Design_in_Ruby-EN.pdf</a>

<h2>Table of Contents (click to jump)</h2>

<a href="#chap1">1. Object-Oriented Design</a>
<a href="#chap2">2. Designing Classes with a Single Responsibility</a>
   - Deciding What Belongs in a Class
   - Grouping Methods into Classes
   - Organizing Code to Allow for Easy Changes
   <a href="#srp">- Creating Classes That Have a Single Responsibility</a>
   - An Example Application: Bicycles and Gears
   - Why Single Responsibility Matters
   - Determining If a Class Has a Single Responsibility
   - Determining When to Make Design Decisions
   - Writing Code That Embraces Change
     - Depend on Behavior, Not Data
     <a href="#srp_everywhere">- Enforce Single Responsibility Everywhere</a>
   - Finally, the Real Wheel
   - Summary
3. Managing Dependencies
   - Understanding Dependencies
   - Recognizing Dependencies
     - Coupling Between Objects (CBO)
     - Other Dependencies
   - Writing Loosely Coupled Code
     - Inject Dependencies
     - Isolate Dependencies
     - Remove Argument-Order Dependencies
   - Managing Dependency Direction
     - Reversing Dependencies
     - Choosing Dependency Direction
   - Summary
4. Creating Flexible Interfaces
   - Understanding Interfaces
   - Defining Interfaces
     - Public Interfaces
     - Private Interfaces
   - Responsibilities, Dependencies, and Interfaces
   - Finding the Public Interface
   - An Example Application: Bicycle Touring Company
     - Constructing an Intention
     - Using Sequence Diagrams
     - Asking for “What” Instead of Telling “How”
     - Seeking Context Independence
     - Trusting Other Objects
     - Using Messages to Discover Objects
     - Creating a Message-Based Application
   - Writing Code That Puts Its Best (Inter)Face Forward
     - Create Explicit Interfaces
     - Honor the Public Interfaces of Others
     - Exercise Caution When Depending on Private Interfaces
     - Minimize Context
   - The Law of Demeter
     - Defining Demeter
     - Consequences of Violations
     - Avoiding Violations
     - Listening to Demeter
   - Summary
5. Reducing Costs with Duck Typing
   - Understanding Duck Typing
   - Overlooking the Duck
   - Compounding the Problem
   - Finding the Duck
   - Consequences of Duck Typing
   - Writing Code That Relies on Ducks
     - Recognizing Hidden Ducks
     - Placing Trust in Your Ducks
     - Documenting Duck Types
     - Sharing Code Between Ducks
     - Choosing Your Ducks Wisely
   - Conquering a Fear of Duck Typing
   - Subverting Duck Types with Static Typing
     - Static versus Dynamic Typing
     - Embracing Dynamic Typing
   - Summary
6. Acquiring Behavior Through Inheritance
   - Understanding Classical Inheritance
   - Recognizing Where to Use Inheritance
     - Starting with a Concrete Class
     - Embedding Multiple Types
     - Finding the Embedded Types
   - Choosing Inheritance
   - Drawing Inheritance Relationships
   - Misapplying Inheritance
   - Finding the Abstraction
   - Creating an Abstract Superclass
     - Promoting Abstract Behavior
     - Separating Abstract from Concrete
   - Using the Template Method Pattern
     - Implementing Every Template Method
   - Managing Coupling Between Superclasses and Subclasses
     - Understanding Coupling
     - Decoupling Subclasses Using Hook Messages
   - Summary
7. Sharing Role Behavior with Modules
   - Understanding Roles
   - Finding Roles
   - Organizing Responsibilities
   - Removing Unnecessary Dependencies
   - Writing the Concrete Code
   - Extracting the Abstraction
   - Looking Up Methods
   - Inheriting Role Behavior
     - Writing Inheritable Code
     - Recognize the Antipatterns
     - Insist on the Abstraction
     - Honor the Contract
8. Testing
   - Testing Private Methods
     - Ignoring Private Methods During Tests
     - Removing Private Methods from the Class Under Test
     - Choosing to Test a Private Method
   - Testing Outgoing Messages
     - Ignoring Query Messages
     - Proving Command Messages
   - Testing Duck Types
   - Testing Roles
     - Using Role Tests to Validate Doubles
   - Testing Inherited Code
     - Specifying the Inherited Interface
     - Specifying Subclass Responsibilities
     - Testing Unique Behavior
   - Summary

<h2 id="chap1">Chapter 1: Object-oriented design (OOD)</h2>

While procedural programming follows a fixed sequence of steps, OOD models the
world as interacting objects with independent behaviors. This enables emergent
behavior without explicitly coding every scenario. OOD requires shifting
perspective from procedures to message-passing between objects. 

Software exists to fulfill a purpose, and efficient, enjoyable programming
aligns with cost-effective development. Object-oriented design (OOD) addresses
both technical and moral challenges by making code flexible and maintainable.
While a perfectly static application wouldn't require design, real-world
software inevitably changes. Changing requirements introduce challenges akin to
friction and gravity, making adaptability crucial. Well-designed applications
are easy to modify and extend, while rigid ones become costly and frustrating
to maintain.

Change is difficult because object-oriented applications consist of
interconnected parts that depend on each other. Dependencies make objects
resistant to modification, causing small changes to ripple unpredictably
through the system. Poorly managed dependencies lead to inflexible,
hard-to-test, and duplicated code. While bad design in small applications may
be manageable, as they grow, they become fragile and difficult to maintain.
Good design minimizes dependencies, making code easier to change, reuse, and
test.

Design is the arrangement of code within an application, and it varies between
programmers like an art form. Good design balances immediate functionality with
future adaptability, as the cost of change will eventually surpass initial
development costs. Practical design does not try to predict specific future
requirements but instead keeps options open. Its main purpose is to make future
design possible and reduce the cost of change.

Design is both an art and a science. While every programmer arranges code
differently, good design follows established principles that reduce the cost of
change and keep future options open. The SOLID principles, DRY, and the Law of
Demeter emerged from experience, but their effectiveness was later confirmed
through empirical research. Early studies measured object-oriented design
metrics in small applications, and later studies—such as those analyzing NASA
software—validated that well-designed code correlates with higher quality and
lower costs. Ultimately, good design isn't just opinion; it has measurable
benefits.

The Gang of Four (GoF) formalized common solutions to recurring design
problems, making software more modular, reusable, and understandable. Patterns
provide a shared language for developers, improving communication and
collaboration. However, misuse—applying patterns to the wrong problems—can lead
to overly complex code. While this book does not focus on patterns, it aims to
equip readers with the foundational knowledge needed to understand and apply
them effectively.

While object-oriented design (OOD) principles and patterns provide a strong
foundation, applying them effectively remains a challenge. Design is not just
about knowing the right principles—it requires skill, experience, and judgment.
The analogy to woodworking highlights that having good tools doesn’t guarantee
good results; mastery comes from practice. Well-designed software, like
well-crafted furniture, depends on the expertise of the creator.

ways design fails:

    Lack of Design:
    Beginners can write working applications without understanding design
    principles, but these applications become difficult to modify over time.
    Early ease leads to long-term frustration as changes break everything.

    Overdesign:
    Intermediate programmers, excited by their newfound knowledge, overapply
    principles and patterns, creating rigid, overly complex systems. Instead of
    allowing for flexibility, their designs become barriers to change.

    Disconnected Design:
    When design is separated from programming, often in rigid top-down
    approaches, it fails to evolve with real-world needs. Without iterative
    feedback, initial misunderstandings become baked into the system, leading
    to impractical implementations.


The key takeaway is that good design is iterative and must evolve alongside
development. Agile methodologies align well with this approach, ensuring that
design remains adaptable and responsive to real-world changes.

Good software design isn't about writing the most code or following arbitrary
metrics—it’s about ``minimizing the long-term cost of change'' while delivering
features in a reasonable timeframe.

<h2 id="chap2">Chapter 2: Designing Classes with a Single Responsibility</h2>

Common Questions in Class Design:
   - How many classes should there be?
   - What behavior should they implement?
   - How much should one class know about others?
   - How much should a class expose of itself to the outside world?

Simplicity is Key:
   - In the early stages, the goal is to keep things simple.
   - The application should work but also be easy to change later.  
   - Immediate functionality can be achieved through brute force,
     but ease of change is more challenging and requires thoughtful design.  
   - Easy changeability is what separates good programming from functional programming.
     It involves skill, experience, and a bit of creativity.

Creating Easy-to-Change Applications:
   - Making an application easy to change requires knowledge of design
     principles that promote flexibility and maintainability.
   - By understanding and applying them, one can structure classes to be both
     functional now and flexible in the future.


Deciding What Belongs in a Class:

When designing an object-oriented application, one is faced with the
challenge of deciding what should belong in each class. 

While the implementation of the application might be clear, the organizational
structure is what often proves difficult.

The focus on grouping methods into classes and making these decisions in a
way that allows for future flexibility.

Grouping Methods into Classes:

- The classes defined will shape how you and others perceive and interact with
  the code. They set the boundaries for how functionality is structured, and they
  can potentially constrain future development.

- Perfect organization isn’t expected at the start. Design is a balance between
  the current needs and the potential future changes.

- Preserving flexibility is more critical than achieving a perfect structure at
  the outset. Good design allows for easy changesin the future, even when initial
  choices are inevitably wrong.

Organizing Code for Easy Changes:
The goal is to create code that is easy to change when needed.

Easy to change means:
- No unexpected side effects from changes
- Small changes lead to proportionally small code modifications
- Code is reusable in new contexts
- The easiest way to change code is to add new code that is also easy to change

The mnemonic TRUE (Transparent, Reasonable, Usable, Exemplary):

  Transparent: The consequences of any change should be clear both in the code
  that is changing and in the code that relies on it.

  Reasonable: The cost of any change should be proportional to the benefit it
  provides. Avoid over-engineering or making changes that are costly without
  significant advantages.

  Usable: Existing code should be adaptable and usable in unexpected or new
  contexts without requiring significant rewrites.

  Exemplary: The code should encourage future developers to maintain these
  qualities, making it easy to modify in the future.

<h3 id="srp">Creating Classes That Have a Single Responsibility</h3>

On a bicycle, the gear ratio is:
<pre><code class="language-python">gear_ratio = N_chainring / N_cog</code></pre>
Nouns like "bicycle" and "gear" are candidates for classes, but while "bicycle"
lacks specific behavior, "gear" involves data and behavior (chainrings, cogs,
and ratios), making it suitable for a class.
<pre><code class="language-python">class Gear:
    def __init__(self, chainring, cog):
        self.chainring = chainring
        self.cog = cog

    def ratio(self):
        return self.chainring / float(self.cog)

print(Gear(52, 11).ratio()) # 4.72727272727273
print(Gear(30, 27).ratio()) # 1.11111111111111
</code></pre>

Your cyclist friend requests an enhancement to the Gear calculator.

She has two bikes with the same gearing but different wheel sizes, and wants to
account for the impact of wheel size on the calculation. Larger wheels cover
more distance with each rotation compared to smaller ones. To address this, you
need to calculate "gear inches" which combines both the gear ratio and wheel
size using the formula:

$$ \mathrm{gear \ inches} = D_{\mathrm{wheel}} \times \mathrm{gear \ ratio} $$
Where:
$$ D_{\mathrm{wheel}} = D_{\mathrm{rim}} + 2 D_{\mathrm{tire}}$$
This allows cyclists to compare bikes with different wheel sizes based on their
gearing and wheel size together.

We can change the gear class to add this behavior:
<pre><code class="language-python">class Gear:
    def __init__(self, chainring, cog, rim, tire):
        self.chainring = chainring
        self.cog = cog
        self.rim = rim
        self.tire = tire

    def ratio(self):
        return self.chainring / float(self.cog)

    def gear_inches(self):
        return self.ratio() * (self.rim + (2*self.tire))

print(Gear(52, 11, 26, 1.5).gear_inches()) # 137.1
print(Gear(30, 27, 24, 1.25).gear_inches()) # 125.2
</code></pre>
Writing Code That Embraces Change:
1. Depend on Behavior, Not Data
 - Encapsulate behavior in methods instead of directly accessing data.
   DRY (Don't Repeat Yourself) to ensure each behavior exists in only one place.
 - This makes changes easier since modifying a single method updates behavior
   everywhere it's used.
 - Behavior exists in methods and is triggered by messages.
 - Single-responsibility classes ensure each piece of behavior has one
   authoritative location.

2. Hide Instance Variables
 - Instead of referring directly to instance variables, wrap them in accessor
   methods.
 - In Python this is usually done using the @property decorator.
   and private attributes proceeeded by an underscore.
<pre><code class="language-python">class Gear:
def __init__(self, chainring, cog, adjustment_factor=1):
    self._chainring = chainring
    self._cog = cog
    self._adjustment_factor = adjustment_factor

@property
def cog(self):
    return self._cog * self._adjustment_factor  # Now cog is dynamic

def ratio(self):
        return self._chainring / float(self.cog)  # Uses encapsulated property
</code></pre>
This may seem pointless, however, implementing this method changes cog from
data (which is referenced all over) to behavior (which is defined once). If the
_cog instance variable is referred to ten times and it suddenly needs to be
adjusted, the code will need many changes. However, if _cog is wrapped in a
method, you can change what cog means by implementing your own version of the
method. 

Dealing with data as if it’s an object that understands messages introduces two
new issues:

1. Visibility:
Wrapping the _cog instance variable in a public cog method
exposes this variable to the other objects in your application; any other
object can now send cog to a Gear. It would have been just as easy to create a
private wrapping method, although in python there is no explicit private
methods, they are often indicated by proceeding underscores _ . Although
thinking about this this is not really an issue in python since attributes in
classes can be freely accessed by externally.

2. Because it’s possible to wrap every instance variable in a method and to
therefore treat any variable as if it’s just another object, the distinction
between data and a regular object begins to disappear. While it’s sometimes
expedient to think of parts of your application as behavior-less data, most
things are better thought of as plain old objects. Regardless of how far your
thoughts move in this direction, you should hide data from yourself. Doing so
protects the code from being affected by unexpected changes. Data very often
has behavior that you don’t yet know about. Send messages to access variables,
even if you think of them as data.

<h3>Hide Data Structures</h3>
This principle applies directly to Python, and the equivalent approach would
involve encapsulation and creating structured objects instead of relying
on nested data structures.

Bad Approach: Exposing a Raw Data Structure
<pre><code class="language-python">class ObscuringReferences:
    def __init__(self, data):
        self.data = data  # Stores a 2D array

    def diameters(self):
        # Hardcoded knowledge of the structure (BAD)
        return [cell[0] + (cell[1] * 2) for cell in self.data]
    
# Example usage 
data = [[622, 20], [622, 23], [559, 30], [559, 40]]
obscure = ObscuringReferences(data)
print(obscure.diameters())  # [662, 668, 619, 639]
</code></pre>
Why is this bad?
- `diameters()` directly references the structure of `data`.
   If `data` changes, this method (and others) will break.
- If other methods also depend on `cell[0]` and `cell[1]`,
  this structure is duplicated across the class.
- Hard-to-maintain: If `data` changes (e.g., from lists to dictionaries),
  you have to update every reference.

Good Approach: Encapsulate the Data in Objects

Instead of exposing raw arrays, we encapsulate the structure in a `Wheel`
class, similar to the Ruby `Struct`.
<pre><code class="language-python">from collections import namedtuple

class RevealingReferences:
    Wheel = namedtuple('Wheel', ['rim', 'tire'])  # Struct-like object

    def __init__(self, data):
        self.wheels = self._wheelify(data)  # Convert raw data to structured objects

    def _wheelify(self, data):
        """Convert list of lists into list of Wheel objects"""
        return [self.Wheel(rim, tire) for rim, tire in data]

    def diameters(self):
        """Compute diameters using structured data"""
        return [wheel.rim + (wheel.tire * 2) for wheel in self.wheels]

# Example usage:
data = [[622, 20], [622, 23], [559, 30], [559, 40]]
revealed = RevealingReferences(data)
print(revealed.diameters())  # [662, 668, 619, 639]
</code></pre>
Why is this better?
- `diameters()` no longer cares about the internal structure of the data.
- Instead of `cell[0]`, we use `wheel.rim`, making the code more readable and less error-prone.
- `_wheelify()` isolates the transformation logic.
  If the input format changes, you only modify this one method.

Even Better: Use a Proper Class Instead of `namedtuple`
If `Wheel` needs more behavior, we can use a class instead of `namedtuple`:

<pre><code class="language-python">class Wheel:
    def __init__(self, rim, tire):
        self.rim = rim
        self.tire = tire

    def diameter(self):
        return self.rim + (self.tire * 2)

class RevealingReferences:
    def __init__(self, data):
        self.wheels = self._wheelify(data)

    def _wheelify(self, data):
        return [Wheel(rim, tire) for rim, tire in data]

    def diameters(self):
        return [wheel.diameter() for wheel in self.wheels]

# Example usage:
data = [[622, 20], [622, 23], [559, 30], [559, 40]]
revealed = RevealingReferences(data)
print(revealed.diameters())  # [662, 668, 619, 639]
</code></pre>
Benefits of using a full class:
- The logic of `diameter()` belongs inside `Wheel`,
  making `RevealingReferences` even simpler.
- If `Wheel` later needs more behavior (e.g., weight calculations),
  it can be added without modifying `RevealingReferences`.

Takeaways:
 - Don't expose raw data structures. Convert them into meaningful objects.  
 - Encapsulate transformation logic.
   Use a method like `_wheelify()` to isolate messy data.  
 - Use namedtuples or classes to replace nested data structures.
 - Make behavior belong to the object.
   The `diameter()` method should be in `Wheel`, not in `RevealingReferences`.

<h2 id="srp_everywhere">Enforce Single Responsibility Everywhere</h2>
Designing classes with a single responsibility improves maintainability, but
the same principle applies beyond class design—it should be used throughout
your code.  

Extract Extra Responsibilities from Methods:

Just like classes, methods should also have a single responsibility. This makes
them easier to modify and reuse. You can apply the same design techniques—ask
what the method does and try to summarize its responsibility in one sentence.  

Consider the `diameters` method in a `RevealingReferences` class:

<pre><code class="language-python">def diameters(self):
    return [wheel.rim + (wheel.tire * 2) for wheel in self.wheels]
</code></pre>
This method has two responsibilities:
1. iterating over `self.wheels`
2. calculating the diameter of each wheel.  

To simplify the code, separate these responsibilities into distinct
methods. The refactored version moves the diameter calculation to its
own method:
<pre><code class="language-python">def diameters(self): 
    return [self.diameter(wheel) for wheel in self.wheels] 

def diameter(self, wheel):
    return wheel.rim + (wheel.tire * 2)
</code></pre>
Would you ever need to calculate the diameter of just one wheel? You
already do! This refactoring isn’t overengineering it simply makes the
code cleaner and easier to use elsewhere.  

<h2>Identifying Hidden Responsibilities</h2>
Separating iteration from the action performed on each element is an
easy-to-spot case of multiple responsibilities. However, sometimes the
issue is more subtle.  

Take the `gear_inches` method from a `Gear` class:  
<pre><code class="language-python">def gear_inches(self):
    return self.ratio * (self.rim + (self.tire * 2))
</code></pre>
Does `gear_inches` belong in `Gear`? It might seem reasonable at
first, but something about it feels wrong—it’s messy and unclear.
The real issue is that it does more than one thing.  

Hidden inside `gear_inches` is the calculation for wheel diameter.
Extracting that logic into a separate method makes the class's
responsibilities clearer:
<pre><code class="language-python">def gear_inches(self):
    return self.ratio * self.diameter()

def diameter(self):
    return self.rim + (self.tire * 2)
</code></pre>
Now, `gear_inches` simply retrieves the diameter instead of computing
it. The logic remains unchanged, but the structure is far better.  

Even when you aren’t sure about the final design, these refactorings
help. Good practices don’t require knowing the end goal—they help
reveal it.  

The benefits of single-responsibility methods include:

- Making hidden design flaws obvious – Refactoring methods to have a
  single responsibility clarifies what a class actually does. Even if
  you don’t move methods into different classes right away, making their
  purpose explicit helps future design decisions.  

- Reducing the need for comments – Comments often become outdated, as they
  aren’t executable. If a method requires a comment to explain what part of it
  does, extract that part into a separate method instead. The method name now
  conveys the meaning.  

- Encouraging reuse – Small methods naturally lead to reusable code. Other
  developers (or your future self) will reuse methods instead of duplicating
  logic, reinforcing good coding habits.  

- Making code easier to refactor – When design changes arise, small methods are
  easier to move between classes, reducing the effort needed to restructure code.  

While each individual refactoring may seem small, their combined impact results
in cleaner, more maintainable code.




<hr>
<div id="clock" onload="currentTime()"></div>
<script type="text/javascript" src="../clock.js"></script>

</div>
</body>
</html>
